// 
#[derive(Debug, Clone, PartialEq)]
pub struct Position {
    pub line: usize,
    pub col: usize,
}

#[derive(Debug)]
pub struct TokenWithPosition {
    pub token: Token,
    pub position: Position,
}


#[derive(Debug)]
pub enum Token{
    // Keywords
    Utl, 
    Off, 
    Onoff, 
    On, 
    Wii, 
    Mote, 
    Dec, 
    Kf, 
    Ont, 
    Uont, 
    Michi, 
    Ntr, 
    Chip, 
    Yes,
    No,
    Yesorno,
    Next,
    Ash,
    Brokie,
    Send,
    Tnirp,
    Tupni,
    Join,

    // Identifiers
    Identifier(String),

    // Literals
    IntegerLiteral(i32),
    FloatLiteral(f64),
    CharLiteral(char),
    StringLiteral(String),

    // Operators
    Is,
    Plus,
    Plusplus,
    Mult,
    Minus,
    Minusminus,
    By,
    Mod,

    // Logical Operators
    And,
    Or,
    Nah,
    Great,
    Lesst,
    Eq,
    Noteq,


    // Punctuation
    Semicolon,
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    LeftBracket,
    RightBracket,

    // Errores
    Error(String),
}


impl Token {
    pub fn get_token(token_type: &str, value: Option<&str>) -> Token {
        match token_type {
            "Utl" => Token::Utl,
            "Off" => Token::Off,
            "Onoff" => Token::Onoff,
            "On" => Token::On,
            "Wii" => Token::Wii,
            "Mote" => Token::Mote,
            "Dec" => Token::Dec,
            "Kf" => Token::Kf,
            "Ont" => Token::Ont,
            "Uont" => Token::Uont,
            "Michi" => Token::Michi,
            "Ntr" => Token::Ntr,
            "Chip" => Token::Chip,
            "Yes" => Token::Yes,
            "No" => Token::No,
            "Yesorno" => Token::Yesorno,
            "Next" => Token::Next,
            "Ash" => Token::Ash,
            "Brokie" => Token::Brokie,
            "Send" => Token::Send,
            "Tnirp" => Token::Tnirp,
            "Tupni" => Token::Tupni,
            "Join" => Token::Join,

            "Identifier" => Token::Identifier(value.unwrap().to_string()),
            "IntegerLiteral" => Token::IntegerLiteral(value.unwrap().parse::<i32>().unwrap()),
            "FloatLiteral" => Token::FloatLiteral(value.unwrap().parse::<f64>().unwrap()),
            "CharLiteral" => Token::CharLiteral(value.unwrap().chars().next().unwrap()),
            "StringLiteral" => Token::StringLiteral(value.unwrap().to_string()),

            "Is" => Token::Is,
            "Plus" => Token::Plus,
            "Plusplus" => Token::Plusplus,
            "Mult" => Token::Mult,
            "Minus" => Token::Minus,
            "Minusminus" => Token::Minusminus,
            "By" => Token::By,
            "Mod" => Token::Mod,
            "And" => Token::And,
            "Or" => Token::Or,
            "Nah" => Token::Nah,
            "Great" => Token::Great,
            "Lesst" => Token::Lesst,
            "Eq" => Token::Eq,
            "Noteq" => Token::Noteq,
            "Semicolon" => Token::Semicolon,
            "LeftParen" => Token::LeftParen,
            "RightParen" => Token::RightParen,
            "LeftBrace" => Token::LeftBrace,
            "RightBrace" => Token::RightBrace,
            "LeftBracket" => Token::LeftBracket,
            "RightBracket" => Token::RightBracket,
            _ => Token::Error("Lexema invalido".to_string()),
        }
    }


    pub fn get_token_regex(token_type: &str) -> String {
        match token_type {
            "Utl" => r"\butl\b",
            "Off" => r"\boff\b",
            "Onoff" => r"\bonoff\b",
            "On" => r"\bon\b",
            "Wii" => r"\bwii\b",
            "Mote" => r"\bmote\b",
            "Dec" => r"\bdec\b",
            "Kf" => r"\bkf\b",
            "Ont" => r"\bont\b",
            "Uont" => r"\buont\b",
            "Michi" => r"\bmichi\b",
            "Ntr" => r"\bntr\b",
            "Chip" => r"\bchip\b",
            "Yes" => r"\byes\b",
            "No" => r"\bno\b",
            "Yesorno" => r"\byesorno\b",
            "Next" => r"\bnext\b",
            "Ash" => r"\bash\b",
            "Brokie" => r"\bbrokie\b",
            "Send" => r"\bsend\b",
            "Tnirp" => r"\btnirp\b",
            "Tupni" => r"\btupni\b",
            "Join" => r"\bjoin\b",

            "Identifier" => r"\b[a-zA-Z_][a-zA-Z0-9_]*\b",

            "Is" => r"\bis\b",
            "Plus" => r"\bplus\b",
            "Plusplus" => r"\bplusplus\b",
            "Mult" => r"\bmult\b",
            "Minus" => r"\bminus\b",
            "Minusminus" => r"\bminusminus\b",
            "By" => r"\bby\b",
            "Mod" => r"\bmod\b",
            "And" => r"\band\b",
            "Or" => r"\bor\b",
            "Nah" => r"\bnah\b",
            "Great" => r"\bgreat\b",
            "Lesst" => r"\blesst\b",
            "Eq" => r"\beq\b",
            "Noteq" => r"\bnoteq\b",

            "IntegerLiteral" => r"\b\d+\b",
            "FloatLiteral" => r"\b\d+\.\d+\b",
            "CharLiteral" => r"'.'",
            "StringLiteral" => r#"\"[^\"]*\""#,

            "Semicolon" => r";",
            "LeftParen" => r"\(",
            "RightParen" => r"\)",
            "LeftBrace" => r"\{",
            "RightBrace" => r"\}",
            "LeftBracket" => r"\[",
            "RightBracket" => r"\]",
            _ => panic!("Invalid token type: {}", token_type),
        }.to_string()
    }


    pub fn name(&self) -> &str {
        match self {
            Token::Utl => "Utl",
            Token::Off => "Off",
            Token::Onoff => "Onoff",
            Token::On => "On",
            Token::Wii => "Wii",
            Token::Mote => "Mote",
            Token::Dec => "Dec",
            Token::Kf => "Kf",
            Token::Ont => "Ont",
            Token::Uont => "Uont",
            Token::Michi => "Michi",
            Token::Ntr => "Ntr",
            Token::Chip => "Chip",
            Token::Yes => "Yes",
            Token::No => "No",
            Token::Yesorno => "Yesorno",
            Token::Next => "Next",
            Token::Ash => "Ash",
            Token::Brokie => "Brokie",
            Token::Send => "Send",
            Token::Tnirp => "Tnirp",
            Token::Tupni => "Tupni",
            Token::Join => "Join",
            Token::Identifier(_) => "Identifier",
            Token::IntegerLiteral(_) => "IntegerLiteral",
            Token::FloatLiteral(_) => "FloatLiteral",
            Token::CharLiteral(_) => "CharLiteral",
            Token::StringLiteral(_) => "StringLiteral",
            Token::Is => "Is",
            Token::Plus => "Plus",
            Token::Plusplus => "Plusplus",
            Token::Mult => "Mult",
            Token::Minus => "Minus",
            Token::Minusminus => "Minusminus",
            Token::By => "By",
            Token::Mod => "Mod",
            Token::And => "And",
            Token::Or => "Or",
            Token::Nah => "Nah",
            Token::Great => "Great",
            Token::Lesst => "Lesst",
            Token::Eq => "Eq",
            Token::Noteq => "Noteq",
            Token::Semicolon => "Semicolon",
            Token::LeftParen => "LeftParen",
            Token::RightParen => "RightParen",
            Token::LeftBrace => "LeftBrace",
            Token::RightBrace => "RightBrace",
            Token::LeftBracket => "LeftBracket",
            Token::RightBracket => "RightBracket",
            _ => "Error",
        }
    }
    
    pub fn value(&self) -> String {
        match self {
            Token::Utl => "utl".into(),
            Token::Off => "off".into(),
            Token::Onoff => "onoff".into(),
            Token::On => "on".into(),
            Token::Wii => "wil".into(),
            Token::Mote => "mote".into(),
            Token::Dec => "dec".into(),
            Token::Kf => "kf".into(),
            Token::Ont => "ont".into(),
            Token::Uont => "uont".into(),
            Token::Michi => "michi".into(),
            Token::Ntr => "ntr".into(),
            Token::Chip => "chip".into(),
            Token::Yes => "yes".into(),
            Token::No => "no".into(),
            Token::Yesorno => "yesorno".into(),
            Token::Next => "next".into(),
            Token::Ash => "ash".into(),
            Token::Brokie => "brokie".into(),
            Token::Send => "send".into(),
            Token::Tnirp => "tnirp".into(),
            Token::Tupni => "tupni".into(),
            Token::Join => "join".into(),
            Token::Is => "is".into(),
            Token::Plus => "plus".into(),
            Token::Plusplus => "plusplus".into(),
            Token::Mult => "mult".into(),
            Token::Minus => "minus".into(),
            Token::Minusminus => "minusminus".into(),
            Token::By => "by".into(),
            Token::Mod => "mod".into(),
            Token::And => "and".into(),
            Token::Or => "or".into(),
            Token::Nah => "nah".into(),
            Token::Great => "great".into(),
            Token::Lesst => "lesst".into(),
            Token::Eq => "eq".into(),
            Token::Noteq => "noteq".into(),
            Token::Semicolon => "semicolon".into(),
            Token::LeftParen => "(".into(),
            Token::RightParen => ")".into(),
            Token::LeftBrace => "[".into(),
            Token::RightBrace => "]".into(),
            Token::LeftBracket => "{".into(),
            Token::RightBracket => "}".into(),
            Token::Identifier(s) | Token::StringLiteral(s) | Token::Error(s) => s.clone(),
            Token::IntegerLiteral(i) => i.to_string(),
            Token::FloatLiteral(f) => f.to_string(),
            Token::CharLiteral(c) => c.to_string(),
        }
    }
}
